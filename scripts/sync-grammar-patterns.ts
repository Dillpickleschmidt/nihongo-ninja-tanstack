#!/usr/bin/env bun
/**
 * Syncs grammar patterns from a SQLite database to TypeScript const
 * Usage: bunx tsx scripts/sync-grammar-patterns.ts <db-path>
 * Example: bunx tsx scripts/sync-grammar-patterns.ts ~/path/to/transcripts.db
 */

import Database from "better-sqlite3"
import fs from "fs"
import path from "path"
import { fileURLToPath } from "url"
import { dirname } from "path"

const __filename = fileURLToPath(import.meta.url)
const __dirname = dirname(__filename)

const dbPath = process.argv[2]

if (!dbPath) {
  console.error("‚ùå Error: Database path required")
  console.error("Usage: bun scripts/sync-grammar-patterns.ts <db-path>")
  process.exit(1)
}

const resolvedDbPath = dbPath.startsWith("~")
  ? dbPath.replace("~", process.env.HOME || "")
  : dbPath

if (!fs.existsSync(resolvedDbPath)) {
  console.error(`‚ùå Error: Database not found at ${resolvedDbPath}`)
  process.exit(1)
}

console.log(`üìñ Reading grammar patterns from: ${resolvedDbPath}`)

const db = new Database(resolvedDbPath, { readonly: true })

// Fetch all grammar patterns
const patterns = db
  .prepare("SELECT pattern_name, jlpt_level FROM grammar_patterns ORDER BY pattern_name")
  .all() as Array<{ pattern_name: string; jlpt_level: string }>

db.close()

if (patterns.length === 0) {
  console.warn("‚ö†Ô∏è  No grammar patterns found in database")
}

// Load existing grammar_to_modules to check for missing mappings
const grammarToModulesPath = path.join(
  __dirname,
  "../src/data/grammar_to_modules.ts",
)

let existingMappedPatterns = new Set<string>()
if (fs.existsSync(grammarToModulesPath)) {
  const content = fs.readFileSync(grammarToModulesPath, "utf-8")
  // Extract pattern names from the const (simple regex)
  const matches = content.match(/'([^']+)':/g) || []
  existingMappedPatterns = new Set(matches.map((m) => m.slice(1, -2)))
}

// Generate TypeScript code
const typeScriptCode = `// AUTO-GENERATED by scripts/sync-grammar-patterns.ts
// DO NOT EDIT MANUALLY - Run: bun run sync-grammar

export const GRAMMAR_PATTERNS = {
${patterns.map((p) => `  '${p.pattern_name}': { jlptLevel: '${p.jlpt_level}' },`).join("\n")}
} as const;

export type GrammarPatternId = keyof typeof GRAMMAR_PATTERNS;
export type JLPTLevel = ${patterns
  .map((p) => `'${p.jlpt_level}'`)
  .filter((v, i, a) => a.indexOf(v) === i)
  .join(" | ")};
`

// Write to file
const outputPath = path.join(__dirname, "../src/data/grammar_patterns.ts")
fs.writeFileSync(outputPath, typeScriptCode, "utf-8")

console.log(`‚úÖ Generated: ${outputPath}`)
console.log(`üìä Total patterns: ${patterns.length}`)

// Validation: Check for patterns without mappings
const unmappedPatterns = patterns.filter(
  (p) => !existingMappedPatterns.has(p.pattern_name),
)

if (unmappedPatterns.length > 0) {
  console.log(
    `\n‚ö†Ô∏è  WARNING: ${unmappedPatterns.length} pattern(s) not in GRAMMAR_TO_MODULES:`,
  )
  unmappedPatterns.forEach((p) => {
    console.log(`   - '${p.pattern_name}' (${p.jlpt_level})`)
  })
  console.log("\n   Add these to src/data/grammar_to_modules.ts\n")
}

console.log("‚ú® Sync complete!")
