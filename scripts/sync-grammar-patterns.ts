#!/usr/bin/env bun
/**
 * Syncs grammar patterns from a Rust patterns.rs file to TypeScript const
 * Usage: bun scripts/sync-grammar-patterns.ts <path-to-patterns.rs>
 * Example: bun scripts/sync-grammar-patterns.ts ~/path/to/patterns.rs
 */

import fs from "fs"
import path from "path"
import { fileURLToPath } from "url"
import { dirname } from "path"

const __filename = fileURLToPath(import.meta.url)
const __dirname = dirname(__filename)

const rustFilePath = process.argv[2]

if (!rustFilePath) {
  console.error("‚ùå Error: Rust file path required")
  console.error(
    "Usage: bun scripts/sync-grammar-patterns.ts <path-to-patterns.rs>",
  )
  process.exit(1)
}

const resolvedPath = rustFilePath.startsWith("~")
  ? rustFilePath.replace("~", process.env.HOME || "")
  : rustFilePath

if (!fs.existsSync(resolvedPath)) {
  console.error(`‚ùå Error: Rust file not found at ${resolvedPath}`)
  process.exit(1)
}

console.log(`üìñ Reading grammar patterns from: ${resolvedPath}`)

const rustContent = fs.readFileSync(resolvedPath, "utf-8")

// Parse the declare_patterns! macro to extract pattern names and JLPT levels
// Pattern format in Rust:
//   VariantName {
//       name: "pattern_name",
//       ...
//       jlpt: "n5",
//   },
const patternRegex =
  /(\w+)\s*\{\s*name:\s*"([^"]+)"[^}]*jlpt:\s*"([^"]+)"[^}]*\}/g

const patterns: Array<{ pattern_name: string; jlpt_level: string }> = []
let match: RegExpExecArray | null

while ((match = patternRegex.exec(rustContent)) !== null) {
  patterns.push({
    pattern_name: match[2],
    jlpt_level: match[3],
  })
}

if (patterns.length === 0) {
  console.warn("‚ö†Ô∏è  No grammar patterns found in Rust file")
  process.exit(1)
}

// Load existing grammar_to_modules to check for missing mappings
const grammarToModulesPath = path.join(
  __dirname,
  "../src/data/grammar_to_modules.ts",
)

let existingMappedPatterns = new Set<string>()
if (fs.existsSync(grammarToModulesPath)) {
  const content = fs.readFileSync(grammarToModulesPath, "utf-8")
  // Extract pattern names from the const (simple regex)
  const matches = content.match(/'([^']+)':/g) || []
  existingMappedPatterns = new Set(matches.map((m: string) => m.slice(1, -2)))
}

// Generate TypeScript code
const typeScriptCode = `// AUTO-GENERATED by scripts/sync-grammar-patterns.ts
// DO NOT EDIT MANUALLY - Run: bun run sync-grammar (make sure the wasm file is up to date as well)


export const GRAMMAR_PATTERNS = {
${patterns.map((p) => `  '${p.pattern_name}': { jlptLevel: '${p.jlpt_level}' },`).join("\n")}
} as const;

export type GrammarPatternId = keyof typeof GRAMMAR_PATTERNS;
export type JLPTLevel = ${patterns
    .map((p) => `'${p.jlpt_level}'`)
    .filter((v, i, a) => a.indexOf(v) === i)
    .join(" | ")};
`

// Write to file
const outputPath = path.join(__dirname, "../src/data/grammar_patterns.ts")
fs.writeFileSync(outputPath, typeScriptCode, "utf-8")

console.log(`‚úÖ Generated: ${outputPath}`)
console.log(`üìä Total patterns: ${patterns.length}`)

// Validation: Check for patterns without mappings
const unmappedPatterns = patterns.filter(
  (p) => !existingMappedPatterns.has(p.pattern_name),
)

if (unmappedPatterns.length > 0) {
  console.log(
    `\n‚ö†Ô∏è  WARNING: ${unmappedPatterns.length} pattern(s) not in GRAMMAR_TO_MODULES:`,
  )
  unmappedPatterns.forEach((p) => {
    console.log(`   - '${p.pattern_name}' (${p.jlpt_level})`)
  })
  console.log("\n   Add these to src/data/grammar_to_modules.ts\n")
}

console.log("‚ú® Sync complete!")
