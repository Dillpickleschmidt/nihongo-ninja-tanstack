create type "public"."practice_item_type" as enum ('vocabulary', 'kanji', 'radical');

create type "public"."practice_mode_enum" as enum ('meanings', 'spellings');

create table "public"."deck_folders" (
    "folder_id" bigint generated always as identity not null,
    "user_id" uuid not null,
    "folder_name" text not null,
    "parent_folder_id" bigint,
    "created_at" timestamp with time zone not null default now()
);


create table "public"."fsrs_cards" (
    "id" bigint generated by default as identity not null,
    "user_id" uuid not null,
    "practice_item_key" text not null,
    "lesson_id" text,
    "created_at" timestamp with time zone not null default (now() AT TIME ZONE 'utc'::text),
    "fsrs_card" jsonb not null,
    "fsrs_logs" jsonb[],
    "due_at" timestamp with time zone not null,
    "stability" real not null,
    "mode" text not null default 'readings'::text,
    "type" practice_item_type not null default 'vocabulary'::practice_item_type
);


alter table "public"."fsrs_cards" enable row level security;

create table "public"."profiles" (
    "user_id" uuid not null default gen_random_uuid(),
    "display_name" text,
    "user_preferences" jsonb not null
);


alter table "public"."profiles" enable row level security;

create table "public"."public_deck_shares" (
    "deck_id" bigint not null,
    "shared_by" uuid not null,
    "shared_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now(),
    "import_count" integer not null default 0
);


create table "public"."user_decks" (
    "deck_id" bigint generated always as identity not null,
    "user_id" uuid not null,
    "deck_name" text not null,
    "deck_description" text,
    "created_at" timestamp with time zone not null default now(),
    "folder_id" bigint,
    "source" text not null default 'user'::text,
    "original_deck_id" text,
    "allowed_practice_modes" practice_mode_enum[] not null
);


create table "public"."user_module_completions" (
    "id" bigint generated by default as identity not null,
    "user_id" uuid not null,
    "module_path" text not null,
    "completed_at" timestamp with time zone not null default timezone('utc'::text, now())
);


alter table "public"."user_module_completions" enable row level security;

create table "public"."vocabulary_items" (
    "id" bigint generated always as identity not null,
    "deck_id" bigint not null,
    "word" text not null,
    "furigana" text,
    "english" text[] not null,
    "info" text[],
    "mnemonics" jsonb,
    "example_sentences" jsonb,
    "videos" jsonb,
    "particles" jsonb,
    "created_at" timestamp with time zone not null default now(),
    "is_verb" boolean default false
);


CREATE UNIQUE INDEX deck_folders_pkey ON public.deck_folders USING btree (folder_id);

CREATE INDEX idx_deck_folders_parent_id ON public.deck_folders USING btree (parent_folder_id);

CREATE INDEX idx_deck_folders_user_id ON public.deck_folders USING btree (user_id);

CREATE INDEX idx_practice_item_user_completions_user_due ON public.fsrs_cards USING btree (user_id, due_at);

CREATE INDEX idx_practice_item_user_completions_user_id ON public.fsrs_cards USING btree (user_id);

CREATE INDEX idx_practice_item_user_completions_user_key ON public.fsrs_cards USING btree (user_id, practice_item_key);

CREATE INDEX idx_public_deck_shares_shared_by ON public.public_deck_shares USING btree (shared_by);

CREATE INDEX idx_static_module_user_completions_user_id ON public.user_module_completions USING btree (user_id);

CREATE INDEX idx_user_decks_folder_id ON public.user_decks USING btree (folder_id);

CREATE INDEX idx_user_decks_user_id ON public.user_decks USING btree (user_id);

CREATE INDEX idx_vocabulary_items_deck_id ON public.vocabulary_items USING btree (deck_id);

CREATE INDEX idx_vocabulary_items_word ON public.vocabulary_items USING btree (word);

CREATE UNIQUE INDEX practice_item_user_completions_id_key ON public.fsrs_cards USING btree (id);

CREATE UNIQUE INDEX practice_item_user_completions_pkey ON public.fsrs_cards USING btree (id);

CREATE UNIQUE INDEX practice_item_user_completions_user_id_pkey_type_unique ON public.fsrs_cards USING btree (user_id, practice_item_key, type);

CREATE UNIQUE INDEX profiles_pkey ON public.profiles USING btree (user_id);

CREATE UNIQUE INDEX public_deck_shares_pkey ON public.public_deck_shares USING btree (deck_id);

CREATE UNIQUE INDEX static_module_user_completions_id_key ON public.user_module_completions USING btree (id);

CREATE UNIQUE INDEX static_module_user_completions_pkey ON public.user_module_completions USING btree (id);

CREATE UNIQUE INDEX static_module_user_completions_user_id_module_path_key ON public.user_module_completions USING btree (user_id, module_path);

CREATE UNIQUE INDEX user_decks_pkey ON public.user_decks USING btree (deck_id);

CREATE UNIQUE INDEX vocabulary_items_pkey ON public.vocabulary_items USING btree (id);

alter table "public"."deck_folders" add constraint "deck_folders_pkey" PRIMARY KEY using index "deck_folders_pkey";

alter table "public"."fsrs_cards" add constraint "practice_item_user_completions_pkey" PRIMARY KEY using index "practice_item_user_completions_pkey";

alter table "public"."profiles" add constraint "profiles_pkey" PRIMARY KEY using index "profiles_pkey";

alter table "public"."public_deck_shares" add constraint "public_deck_shares_pkey" PRIMARY KEY using index "public_deck_shares_pkey";

alter table "public"."user_decks" add constraint "user_decks_pkey" PRIMARY KEY using index "user_decks_pkey";

alter table "public"."user_module_completions" add constraint "static_module_user_completions_pkey" PRIMARY KEY using index "static_module_user_completions_pkey";

alter table "public"."vocabulary_items" add constraint "vocabulary_items_pkey" PRIMARY KEY using index "vocabulary_items_pkey";

alter table "public"."deck_folders" add constraint "deck_folders_parent_fkey" FOREIGN KEY (parent_folder_id) REFERENCES deck_folders(folder_id) ON DELETE CASCADE not valid;

alter table "public"."deck_folders" validate constraint "deck_folders_parent_fkey";

alter table "public"."deck_folders" add constraint "deck_folders_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."deck_folders" validate constraint "deck_folders_user_id_fkey";

alter table "public"."fsrs_cards" add constraint "practice_item_user_completions_id_key" UNIQUE using index "practice_item_user_completions_id_key";

alter table "public"."fsrs_cards" add constraint "practice_item_user_completions_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."fsrs_cards" validate constraint "practice_item_user_completions_user_id_fkey";

alter table "public"."fsrs_cards" add constraint "practice_item_user_completions_user_id_pkey_type_unique" UNIQUE using index "practice_item_user_completions_user_id_pkey_type_unique";

alter table "public"."profiles" add constraint "profiles_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."profiles" validate constraint "profiles_user_id_fkey";

alter table "public"."public_deck_shares" add constraint "public_deck_shares_deck_id_fkey" FOREIGN KEY (deck_id) REFERENCES user_decks(deck_id) ON DELETE CASCADE not valid;

alter table "public"."public_deck_shares" validate constraint "public_deck_shares_deck_id_fkey";

alter table "public"."public_deck_shares" add constraint "public_deck_shares_shared_by_fkey" FOREIGN KEY (shared_by) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."public_deck_shares" validate constraint "public_deck_shares_shared_by_fkey";

alter table "public"."user_decks" add constraint "user_decks_folder_id_fkey" FOREIGN KEY (folder_id) REFERENCES deck_folders(folder_id) ON DELETE SET NULL not valid;

alter table "public"."user_decks" validate constraint "user_decks_folder_id_fkey";

alter table "public"."user_decks" add constraint "user_decks_source_check" CHECK ((source = ANY (ARRAY['built-in'::text, 'anki'::text, 'wanikani'::text, 'jpdb'::text, 'user'::text, 'shared'::text]))) not valid;

alter table "public"."user_decks" validate constraint "user_decks_source_check";

alter table "public"."user_decks" add constraint "user_decks_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."user_decks" validate constraint "user_decks_user_id_fkey";

alter table "public"."user_module_completions" add constraint "static_module_user_completions_id_key" UNIQUE using index "static_module_user_completions_id_key";

alter table "public"."user_module_completions" add constraint "static_module_user_completions_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."user_module_completions" validate constraint "static_module_user_completions_user_id_fkey";

alter table "public"."user_module_completions" add constraint "static_module_user_completions_user_id_module_path_key" UNIQUE using index "static_module_user_completions_user_id_module_path_key";

alter table "public"."vocabulary_items" add constraint "vocabulary_items_deck_id_fkey" FOREIGN KEY (deck_id) REFERENCES user_decks(deck_id) ON DELETE CASCADE not valid;

alter table "public"."vocabulary_items" validate constraint "vocabulary_items_deck_id_fkey";

set check_function_bodies = off;

CREATE OR REPLACE FUNCTION public.execute_edit_transaction(user_id uuid, operations jsonb)
 RETURNS void
 LANGUAGE plpgsql
AS $function$DECLARE
    operation JSONB;
    operation_type TEXT;
    target_id INTEGER;
    updates JSONB;
    new_name TEXT;
    new_folder_id INTEGER;
  BEGIN
    IF operations IS NULL OR jsonb_array_length(operations) = 0 THEN
      RAISE EXCEPTION 'Operations array cannot be empty';
    END IF;

    FOR operation IN SELECT * FROM jsonb_array_elements(operations)
    LOOP
      operation_type := operation->>'type';

      CASE operation_type
        WHEN 'update-deck' THEN
          target_id := (operation->>'deckId')::INTEGER;
          updates := operation->'updates';

          -- Verify ownership
          PERFORM 1 FROM user_decks
          WHERE deck_id = target_id AND user_decks.user_id = execute_edit_transaction.user_id;
          IF NOT FOUND THEN
            RAISE EXCEPTION 'Deck % not found or access denied', target_id;
          END IF;

          -- Handle name update
          IF updates ? 'name' THEN
            new_name := TRIM(updates->>'name');
            IF LENGTH(new_name) = 0 OR LENGTH(new_name) > 80 THEN
              RAISE EXCEPTION 'Name must be between 1 and 80 characters';
            END IF;

            -- Get target folder for duplicate check
            new_folder_id := COALESCE(
              NULLIF(updates->>'folderId', 'null')::INTEGER,
              (SELECT folder_id FROM user_decks WHERE deck_id = target_id)
            );

            -- Check for duplicate names in the same folder
            PERFORM 1 FROM user_decks
            WHERE user_decks.user_id = execute_edit_transaction.user_id
            AND LOWER(deck_name) = LOWER(new_name)
            AND folder_id IS NOT DISTINCT FROM new_folder_id
            AND deck_id != target_id;
            IF FOUND THEN
              RAISE EXCEPTION 'A deck with this name already exists in this folder';
            END IF;
          END IF;

          -- Handle folder update
          IF updates ? 'folderId' THEN
            new_folder_id := NULLIF(updates->>'folderId', 'null')::INTEGER;
            IF new_folder_id IS NOT NULL THEN
              PERFORM 1 FROM deck_folders
              WHERE folder_id = new_folder_id AND deck_folders.user_id = execute_edit_transaction.user_id;
              IF NOT FOUND THEN
                RAISE EXCEPTION 'Target folder % not found', new_folder_id;
              END IF;
            END IF;
          END IF;

          -- Apply updates
          UPDATE user_decks SET
            deck_name = COALESCE(TRIM(updates->>'name'), deck_name),
            folder_id = CASE
              WHEN updates ? 'folderId' THEN NULLIF(updates->>'folderId', 'null')::INTEGER
              ELSE folder_id
            END
          WHERE deck_id = target_id AND user_decks.user_id = execute_edit_transaction.user_id;

        WHEN 'update-folder' THEN
          target_id := (operation->>'folderId')::INTEGER;
          updates := operation->'updates';

          -- Verify ownership
          PERFORM 1 FROM deck_folders
          WHERE folder_id = target_id AND deck_folders.user_id = execute_edit_transaction.user_id;
          IF NOT FOUND THEN
            RAISE EXCEPTION 'Folder % not found or access denied', target_id;
          END IF;

          -- Handle name update
          IF updates ? 'name' THEN
            new_name := TRIM(updates->>'name');
            IF LENGTH(new_name) = 0 OR LENGTH(new_name) > 80 THEN
              RAISE EXCEPTION 'Folder name must be between 1 and 80 characters';
            END IF;

            -- Get target parent for duplicate check
            new_folder_id := COALESCE(
              NULLIF(updates->>'parentId', 'null')::INTEGER,
              (SELECT parent_folder_id FROM deck_folders WHERE folder_id = target_id)
            );

            -- Check for duplicate names in the same parent folder
            PERFORM 1 FROM deck_folders
            WHERE deck_folders.user_id = execute_edit_transaction.user_id
            AND LOWER(folder_name) = LOWER(new_name)
            AND parent_folder_id IS NOT DISTINCT FROM new_folder_id
            AND folder_id != target_id;
            IF FOUND THEN
              RAISE EXCEPTION 'A folder with this name already exists in this location';
            END IF;
          END IF;

          -- Handle parent update (check for circular reference)
          IF updates ? 'parentId' THEN
            new_folder_id := NULLIF(updates->>'parentId', 'null')::INTEGER;
            IF new_folder_id IS NOT NULL THEN
              -- Verify parent folder exists and user owns it
              PERFORM 1 FROM deck_folders
              WHERE folder_id = new_folder_id AND deck_folders.user_id = execute_edit_transaction.user_id;
              IF NOT FOUND THEN
                RAISE EXCEPTION 'Parent folder % not found', new_folder_id;
              END IF;

              -- Check for circular reference using recursive CTE
              WITH RECURSIVE folder_ancestry AS (
                SELECT folder_id, parent_folder_id FROM deck_folders WHERE folder_id = new_folder_id AND deck_folders.user_id = execute_edit_transaction.user_id
                UNION ALL
                SELECT df.folder_id, df.parent_folder_id FROM deck_folders df INNER JOIN folder_ancestry fa ON df.folder_id = fa.parent_folder_id WHERE df.user_id = execute_edit_transaction.user_id
              )
              SELECT 1 FROM folder_ancestry WHERE folder_id = target_id;
              IF FOUND THEN
                RAISE EXCEPTION 'Cannot move folder into its own descendant (circular reference)';
              END IF;
            END IF;
          END IF;

          -- Apply updates
          UPDATE deck_folders SET
            folder_name = COALESCE(TRIM(updates->>'name'), folder_name),
            parent_folder_id = CASE
              WHEN updates ? 'parentId' THEN NULLIF(updates->>'parentId', 'null')::INTEGER
              ELSE parent_folder_id
            END
          WHERE folder_id = target_id AND deck_folders.user_id = execute_edit_transaction.user_id;

        WHEN 'update-deck-vocabulary' THEN
          target_id := (operation->>'deckId')::INTEGER;

          -- Verify ownership
          PERFORM 1 FROM user_decks
          WHERE deck_id = target_id AND user_decks.user_id = execute_edit_transaction.user_id;
          IF NOT FOUND THEN
            RAISE EXCEPTION 'Deck % not found or access denied', target_id;
          END IF;

          -- Delete existing vocabulary items
          DELETE FROM vocabulary_items WHERE deck_id = target_id;

          -- Insert new vocabulary items
          IF operation ? 'vocabularyItems' AND jsonb_array_length(operation->'vocabularyItems') > 0 THEN
            INSERT INTO vocabulary_items (
              deck_id, word, furigana, english, part_of_speech,
              chapter, info, mnemonics, example_sentences, particles, videos
            )
            SELECT
              target_id,
              item_data->>'word',
              item_data->>'furigana',
              ARRAY(SELECT jsonb_array_elements_text(item_data->'english')),
              NULLIF(item_data->>'part_of_speech', '')::part_of_speech,
              COALESCE((item_data->>'chapter')::integer, 1),
              CASE
                WHEN item_data->'info' IS NOT NULL AND item_data->'info' != 'null'::jsonb
                THEN ARRAY(SELECT jsonb_array_elements_text(item_data->'info'))
                ELSE NULL
              END,
              item_data->'mnemonics',
              item_data->'example_sentences',
              item_data->'particles',
              item_data->'videos'
            FROM jsonb_array_elements(operation->'vocabularyItems') AS item_data;
          END IF;

         WHEN 'delete-deck' THEN                        
           target_id := (operation->>'deckId')::INTEGER;
                                                
           -- Verify ownership                          
           PERFORM 1 FROM user_decks                    
           WHERE deck_id = target_id AND                
           user_decks.user_id = execute_edit_transaction.user_id;              
           IF NOT FOUND THEN                            
             RAISE EXCEPTION 'Deck % not found or access denied', target_id;                           
           END IF;                                      
                                                
           -- Delete vocabulary items first (foreign key constraint)                                   
           DELETE FROM vocabulary_items WHERE deck_id = target_id;                                     
                                                
           -- Delete the deck                           
           DELETE FROM user_decks                       
           WHERE deck_id = target_id AND                
           user_decks.user_id = execute_edit_transaction.user_id;

        WHEN 'delete-folder' THEN
          target_id := (operation->>'folderId')::INTEGER;
          
          -- Verify ownership
          PERFORM 1 FROM deck_folders
          WHERE folder_id = target_id AND deck_folders.user_id = execute_edit_transaction.user_id;
          IF NOT FOUND THEN
            RAISE EXCEPTION 'Folder % not found or access denied', target_id;
          END IF;
          
          -- Handle deletion strategy
          IF operation->>'strategy' = 'move-up' THEN
            -- Get parent folder ID
            SELECT parent_folder_id INTO new_folder_id FROM deck_folders WHERE folder_id = target_id;
            
            -- Move child folders to parent
            UPDATE deck_folders SET parent_folder_id = new_folder_id WHERE parent_folder_id = target_id AND deck_folders.user_id = execute_edit_transaction.user_id;
            
            -- Move child decks to parent
            UPDATE user_decks SET folder_id = new_folder_id WHERE folder_id = target_id AND user_decks.user_id = execute_edit_transaction.user_id;
            
            -- Delete the folder
            DELETE FROM deck_folders WHERE folder_id = target_id AND deck_folders.user_id = execute_edit_transaction.user_id;
            
          ELSIF operation->>'strategy' = 'delete-all' THEN
            -- Delete all vocabulary items in descendant folders
            WITH RECURSIVE folder_tree AS (
              SELECT folder_id FROM deck_folders WHERE folder_id = target_id AND deck_folders.user_id = execute_edit_transaction.user_id
              UNION ALL
              SELECT df.folder_id FROM deck_folders df INNER JOIN folder_tree ft ON df.parent_folder_id = ft.folder_id WHERE df.user_id = execute_edit_transaction.user_id
            )
            DELETE FROM vocabulary_items WHERE deck_id IN (SELECT deck_id FROM user_decks WHERE folder_id IN (SELECT folder_id FROM folder_tree) AND user_decks.user_id = execute_edit_transaction.user_id);
            
            -- Delete all decks in descendant folders
            WITH RECURSIVE folder_tree AS (
              SELECT folder_id FROM deck_folders WHERE folder_id = target_id AND deck_folders.user_id = execute_edit_transaction.user_id
              UNION ALL
              SELECT df.folder_id FROM deck_folders df INNER JOIN folder_tree ft ON df.parent_folder_id = ft.folder_id WHERE df.user_id = execute_edit_transaction.user_id
            )
            DELETE FROM user_decks WHERE folder_id IN (SELECT folder_id FROM folder_tree) AND user_decks.user_id = execute_edit_transaction.user_id;
            
            -- Delete all descendant folders
            WITH RECURSIVE folder_tree AS (
              SELECT folder_id FROM deck_folders WHERE folder_id = target_id AND deck_folders.user_id = execute_edit_transaction.user_id
              UNION ALL
              SELECT df.folder_id FROM deck_folders df INNER JOIN folder_tree ft ON df.parent_folder_id = ft.folder_id WHERE df.user_id = execute_edit_transaction.user_id
            )
            DELETE FROM deck_folders WHERE folder_id IN (SELECT folder_id FROM folder_tree) AND deck_folders.user_id = execute_edit_transaction.user_id;
            
          ELSE
            RAISE EXCEPTION 'Invalid delete strategy: %', operation->>'strategy';
          END IF;

        ELSE
          RAISE EXCEPTION 'Unknown operation type: %', operation_type;
      END CASE;
    END LOOP;
  END;$function$
;

CREATE OR REPLACE FUNCTION public.handle_new_user()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
  BEGIN
      INSERT INTO public.profiles (user_id,
  user_preferences, display_name)
      VALUES (
          NEW.id,
          '{}',
          NEW.raw_user_meta_data->>'name'
      );

      RETURN NEW;
  END;
  $function$
;

CREATE OR REPLACE FUNCTION public.increment_deck_import_count()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
  BEGIN
    -- Only increment when a deck is successfully imported (source = 'shared')
    -- and has an original_deck_id that corresponds to a shared deck
    IF NEW.source = 'shared' AND NEW.original_deck_id
  IS NOT NULL THEN
      UPDATE public_deck_shares
      SET import_count = import_count + 1
      WHERE deck_id = CAST(NEW.original_deck_id AS
  INTEGER);
    END IF;

    RETURN NEW;
  END;
  $function$
;

CREATE OR REPLACE FUNCTION public.update_updated_at_column()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
    NEW.updated_at = now();
    RETURN NEW;
END;
$function$
;

grant delete on table "public"."deck_folders" to "anon";

grant insert on table "public"."deck_folders" to "anon";

grant references on table "public"."deck_folders" to "anon";

grant select on table "public"."deck_folders" to "anon";

grant trigger on table "public"."deck_folders" to "anon";

grant truncate on table "public"."deck_folders" to "anon";

grant update on table "public"."deck_folders" to "anon";

grant delete on table "public"."deck_folders" to "authenticated";

grant insert on table "public"."deck_folders" to "authenticated";

grant references on table "public"."deck_folders" to "authenticated";

grant select on table "public"."deck_folders" to "authenticated";

grant trigger on table "public"."deck_folders" to "authenticated";

grant truncate on table "public"."deck_folders" to "authenticated";

grant update on table "public"."deck_folders" to "authenticated";

grant delete on table "public"."deck_folders" to "service_role";

grant insert on table "public"."deck_folders" to "service_role";

grant references on table "public"."deck_folders" to "service_role";

grant select on table "public"."deck_folders" to "service_role";

grant trigger on table "public"."deck_folders" to "service_role";

grant truncate on table "public"."deck_folders" to "service_role";

grant update on table "public"."deck_folders" to "service_role";

grant delete on table "public"."fsrs_cards" to "anon";

grant insert on table "public"."fsrs_cards" to "anon";

grant references on table "public"."fsrs_cards" to "anon";

grant select on table "public"."fsrs_cards" to "anon";

grant trigger on table "public"."fsrs_cards" to "anon";

grant truncate on table "public"."fsrs_cards" to "anon";

grant update on table "public"."fsrs_cards" to "anon";

grant delete on table "public"."fsrs_cards" to "authenticated";

grant insert on table "public"."fsrs_cards" to "authenticated";

grant references on table "public"."fsrs_cards" to "authenticated";

grant select on table "public"."fsrs_cards" to "authenticated";

grant trigger on table "public"."fsrs_cards" to "authenticated";

grant truncate on table "public"."fsrs_cards" to "authenticated";

grant update on table "public"."fsrs_cards" to "authenticated";

grant delete on table "public"."fsrs_cards" to "service_role";

grant insert on table "public"."fsrs_cards" to "service_role";

grant references on table "public"."fsrs_cards" to "service_role";

grant select on table "public"."fsrs_cards" to "service_role";

grant trigger on table "public"."fsrs_cards" to "service_role";

grant truncate on table "public"."fsrs_cards" to "service_role";

grant update on table "public"."fsrs_cards" to "service_role";

grant delete on table "public"."profiles" to "anon";

grant insert on table "public"."profiles" to "anon";

grant references on table "public"."profiles" to "anon";

grant select on table "public"."profiles" to "anon";

grant trigger on table "public"."profiles" to "anon";

grant truncate on table "public"."profiles" to "anon";

grant update on table "public"."profiles" to "anon";

grant delete on table "public"."profiles" to "authenticated";

grant insert on table "public"."profiles" to "authenticated";

grant references on table "public"."profiles" to "authenticated";

grant select on table "public"."profiles" to "authenticated";

grant trigger on table "public"."profiles" to "authenticated";

grant truncate on table "public"."profiles" to "authenticated";

grant update on table "public"."profiles" to "authenticated";

grant delete on table "public"."profiles" to "service_role";

grant insert on table "public"."profiles" to "service_role";

grant references on table "public"."profiles" to "service_role";

grant select on table "public"."profiles" to "service_role";

grant trigger on table "public"."profiles" to "service_role";

grant truncate on table "public"."profiles" to "service_role";

grant update on table "public"."profiles" to "service_role";

grant delete on table "public"."public_deck_shares" to "anon";

grant insert on table "public"."public_deck_shares" to "anon";

grant references on table "public"."public_deck_shares" to "anon";

grant select on table "public"."public_deck_shares" to "anon";

grant trigger on table "public"."public_deck_shares" to "anon";

grant truncate on table "public"."public_deck_shares" to "anon";

grant update on table "public"."public_deck_shares" to "anon";

grant delete on table "public"."public_deck_shares" to "authenticated";

grant insert on table "public"."public_deck_shares" to "authenticated";

grant references on table "public"."public_deck_shares" to "authenticated";

grant select on table "public"."public_deck_shares" to "authenticated";

grant trigger on table "public"."public_deck_shares" to "authenticated";

grant truncate on table "public"."public_deck_shares" to "authenticated";

grant update on table "public"."public_deck_shares" to "authenticated";

grant delete on table "public"."public_deck_shares" to "service_role";

grant insert on table "public"."public_deck_shares" to "service_role";

grant references on table "public"."public_deck_shares" to "service_role";

grant select on table "public"."public_deck_shares" to "service_role";

grant trigger on table "public"."public_deck_shares" to "service_role";

grant truncate on table "public"."public_deck_shares" to "service_role";

grant update on table "public"."public_deck_shares" to "service_role";

grant delete on table "public"."user_decks" to "anon";

grant insert on table "public"."user_decks" to "anon";

grant references on table "public"."user_decks" to "anon";

grant select on table "public"."user_decks" to "anon";

grant trigger on table "public"."user_decks" to "anon";

grant truncate on table "public"."user_decks" to "anon";

grant update on table "public"."user_decks" to "anon";

grant delete on table "public"."user_decks" to "authenticated";

grant insert on table "public"."user_decks" to "authenticated";

grant references on table "public"."user_decks" to "authenticated";

grant select on table "public"."user_decks" to "authenticated";

grant trigger on table "public"."user_decks" to "authenticated";

grant truncate on table "public"."user_decks" to "authenticated";

grant update on table "public"."user_decks" to "authenticated";

grant delete on table "public"."user_decks" to "service_role";

grant insert on table "public"."user_decks" to "service_role";

grant references on table "public"."user_decks" to "service_role";

grant select on table "public"."user_decks" to "service_role";

grant trigger on table "public"."user_decks" to "service_role";

grant truncate on table "public"."user_decks" to "service_role";

grant update on table "public"."user_decks" to "service_role";

grant delete on table "public"."user_module_completions" to "anon";

grant insert on table "public"."user_module_completions" to "anon";

grant references on table "public"."user_module_completions" to "anon";

grant select on table "public"."user_module_completions" to "anon";

grant trigger on table "public"."user_module_completions" to "anon";

grant truncate on table "public"."user_module_completions" to "anon";

grant update on table "public"."user_module_completions" to "anon";

grant delete on table "public"."user_module_completions" to "authenticated";

grant insert on table "public"."user_module_completions" to "authenticated";

grant references on table "public"."user_module_completions" to "authenticated";

grant select on table "public"."user_module_completions" to "authenticated";

grant trigger on table "public"."user_module_completions" to "authenticated";

grant truncate on table "public"."user_module_completions" to "authenticated";

grant update on table "public"."user_module_completions" to "authenticated";

grant delete on table "public"."user_module_completions" to "service_role";

grant insert on table "public"."user_module_completions" to "service_role";

grant references on table "public"."user_module_completions" to "service_role";

grant select on table "public"."user_module_completions" to "service_role";

grant trigger on table "public"."user_module_completions" to "service_role";

grant truncate on table "public"."user_module_completions" to "service_role";

grant update on table "public"."user_module_completions" to "service_role";

grant delete on table "public"."vocabulary_items" to "anon";

grant insert on table "public"."vocabulary_items" to "anon";

grant references on table "public"."vocabulary_items" to "anon";

grant select on table "public"."vocabulary_items" to "anon";

grant trigger on table "public"."vocabulary_items" to "anon";

grant truncate on table "public"."vocabulary_items" to "anon";

grant update on table "public"."vocabulary_items" to "anon";

grant delete on table "public"."vocabulary_items" to "authenticated";

grant insert on table "public"."vocabulary_items" to "authenticated";

grant references on table "public"."vocabulary_items" to "authenticated";

grant select on table "public"."vocabulary_items" to "authenticated";

grant trigger on table "public"."vocabulary_items" to "authenticated";

grant truncate on table "public"."vocabulary_items" to "authenticated";

grant update on table "public"."vocabulary_items" to "authenticated";

grant delete on table "public"."vocabulary_items" to "service_role";

grant insert on table "public"."vocabulary_items" to "service_role";

grant references on table "public"."vocabulary_items" to "service_role";

grant select on table "public"."vocabulary_items" to "service_role";

grant trigger on table "public"."vocabulary_items" to "service_role";

grant truncate on table "public"."vocabulary_items" to "service_role";

grant update on table "public"."vocabulary_items" to "service_role";

create policy "user_own_completions_policy"
on "public"."fsrs_cards"
as permissive
for all
to public
using ((auth.uid() = user_id))
with check ((auth.uid() = user_id));


create policy "Enable users to view their own data only"
on "public"."profiles"
as permissive
for select
to authenticated
using ((( SELECT auth.uid() AS uid) = user_id));


create policy "Users can update their own profile"
on "public"."profiles"
as permissive
for update
to authenticated
using ((( SELECT auth.uid() AS uid) = user_id))
with check ((( SELECT auth.uid() AS uid) = user_id));


create policy "user_own_completions_policy"
on "public"."user_module_completions"
as permissive
for all
to public
using (( SELECT (auth.uid() = user_module_completions.user_id)))
with check (( SELECT (auth.uid() = user_module_completions.user_id)));


CREATE TRIGGER update_public_deck_shares_updated_at BEFORE UPDATE ON public.public_deck_shares FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER trigger_increment_import_count AFTER INSERT ON public.user_decks FOR EACH ROW EXECUTE FUNCTION increment_deck_import_count();


