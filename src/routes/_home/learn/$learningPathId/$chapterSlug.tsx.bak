// routes/_home/learn/$learningPathId/$chapterSlug.tsx
import { onMount } from "solid-js"
import { createFileRoute, useRouteContext } from "@tanstack/solid-router"
import { useTour } from "@/features/guided-tour/TourContext"
import { useCustomQuery } from "@/hooks/useCustomQuery"
import {
  chapterModulesQueryOptions,
  allLearningPathsQueryOptions,
} from "@/query/query-options"
import { resourceThumbnailQueryOptions } from "@/query/query-options"
import { enrichExternalResources } from "@/features/learn-page/utils/loader-helpers"
import { userSettingsQueryOptions } from "@/query/query-options"
import { applyUserSettingsUpdate } from "@/query/utils/user-settings"
import type { ExternalResource } from "@/data/types"
import { Route as RootRoute } from "@/routes/__root"
import DesktopLayout from "@/features/learn-page/components/shared/DesktopLayout"

export const Route = createFileRoute(
  "/_home/learn/$learningPathId/$chapterSlug",
)({
  loader: async ({ context, params }) => {
    const { user, queryClient } = context
    const { learningPathId, chapterSlug } = params

    // Get user settings (will be instant cache hit from parent)
    const userSettings = await queryClient.ensureQueryData(
      userSettingsQueryOptions(user?.id || null),
    )

    // Prefetch all learning paths to ensure chapters are available
    queryClient.prefetchQuery(allLearningPathsQueryOptions(user?.id || null))

    // Update active-deck if URL differs from current settings
    const needsUpdate =
      userSettings["active-chapter"] !== chapterSlug ||
      userSettings["active-learning-path"] !== learningPathId

    if (needsUpdate) {
      await applyUserSettingsUpdate(
        user?.id || null,
        queryClient,
        {
          "active-chapter": chapterSlug,
          "active-learning-path": learningPathId,
        },
        { awaitDb: false }, // Don't await DB (non-blocking)
      )
    }

    // Prefetch chapter modules (supports both static and user-created paths)
    queryClient.prefetchQuery(
      chapterModulesQueryOptions(learningPathId, chapterSlug),
    )

    // Pre-fetch resource thumbnails (get modules from cache after prefetch)
    let externalResources: Record<string, ExternalResource> = {}
    try {
      const cachedModules = queryClient.getQueryData([
        "chapter-modules",
        learningPathId,
        chapterSlug,
      ]) as Array<{ key: string; module: any }> | undefined

      if (cachedModules) {
        const rawResources = Object.fromEntries(
          cachedModules
            .filter(({ module }) => "external_url" in module)
            .map(({ key, module }) => [key, module as ExternalResource]),
        )
        externalResources = enrichExternalResources(rawResources)
        const resourcesArray = Object.values(externalResources)
        resourcesArray.forEach((resource) =>
          queryClient.prefetchQuery(
            resourceThumbnailQueryOptions(
              resource.id,
              resource.external_url,
              resource.creator_id,
            ),
          ),
        )
      }
    } catch {
      // Silently fail if resource prefetch fails - not critical for load
    }

    return {
      learningPathId,
      chapterSlug,
      externalResources,
    }
  },
  component: RouteComponent,
})

function RouteComponent() {
  const { startTour, resumeTour } = useTour()
  const context = useRouteContext({ from: RootRoute.id })
  const settingsQuery = useCustomQuery(() =>
    userSettingsQueryOptions(context().user?.id || null),
  )

  onMount(() => {
    const settings = settingsQuery.data
    const tourId = "learn-page-intro"
    const tourStep = settings?.tours[tourId]

    if (tourStep === undefined) {
      // Not started - start from beginning
      startTour(tourId)
    } else if (tourStep >= 0) {
      // In progress - resume from saved step
      resumeTour(tourId, tourStep)
    }
  })

  return <DesktopLayout />
}
